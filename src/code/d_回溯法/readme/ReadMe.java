package code.d_回溯法.readme;

/**
 * @author GengXuelong
 * @version 1.0
 * {@code Mail} 3349495429@qq.com
 * {@code time} 2023/2/27 3:28
 * {@code className} ReadMe
 * {@code description}:
 *      基本思想:从初始状态出发,探索其所能达到的所有状态,当一条路走到尽头,再后退一步或若干步从另外一种状态触发
 *      这种不断前进不断回溯的寻找解的方法叫回溯法
 *      通常将问题组织成树的形式,采用系统的方法搜索解空间树.
 *      搜索策略: 深度优先为主 广度优先 函数优先 广度深度相结合
 *      避免无效搜索策略:
 *      约束函数: 在扩展结点出减去不满足约束条件的子树
 *      界限函数:在扩展结点处减去得不到最优解的子树
 *
 *      问题解的表述: n元式(x1,x2,x3,...)
 *      显示约束: 对x分量的取值限定
 *      隐式约束: 为满足问题的解而对不同分量之间完成的约束
 *      解空间: 解向量满足所有约束条件的所有多元组,构成了问题的一个解空间
 *      结点状态:
 *      百结点: 尚未访问
 *      灰结点: 正在访问以该节点为根的子节点
 *      黑结点: 已将完成访问
 *      存储: 当前路径
 *      回溯法适用问题: 搜索问题和优化问题
 *      必要条件: 多米诺性质
 *      子基树: N皇后
 *      排列数: 货郎问题
 *      回溯法结题框架:(子集树)
 *      void backtrack(int t){
 *          if(t>n) output(x)
 *          else{
 *              for(int i = start(n,t);i<= end(n,t);i++){
 *                  x[i] = h[i]; //当前扩展结点第i个可选值
 *                  if(constraint(t)&&bound(t)){ //约束函数和界限函数
 *                      backtrack(t+1);
 *                  }
 *              }
 *          }
 *      }
 *      框架:(排列树)
 *      void backtrack(int t){
 *          if(t>n) output(x);
 *          else{
 *              for(int i = t;i<=n;i++){
 *                  swap(x[i],x[t]);
 *                  if(bound(t)&&constraint(t)){
 *                      backtrack(t+1);
 *                  }
 *                  swap(x[i],x[t]);
 *              }
 *
 *          }
 *      }
 *
 *      在搜索的过程中,动态产生问题的解空间,在任何时刻,算法只保存从根节点到扩展结点的路径
 *
 *      案例1 : N 皇后问题
 *      案例2: 货郎问题
 *      案例3: 装载问题
 *      案例4: 批作业调度为题,排列数,类同与货郎问题
 *      案例5: 0-1背包问题
 *          装载问题的上界函数为
 *          当前载量cp+剩余可选
 *          集装箱重量和r >当前最
 *          优装载量bestp;
 *          对于0-1背包问题，更好
 *          的上界为：当前价值cv+
 *          剩余容量可容纳的最大
 *          价值 >当前最优价值bestp
 *
 *      案例6: 最大团问题 .无向图G的最大团和最大独立集问题可以看作是图G的顶点集V
 * 的子集选取问题
 *      子集选取问题
 *      解向量: xi 代表第i个结点是否包含
 *      隐式约束: xi = {0,1}
 *      显示约束: xi=1的所有结点都互相连接
 *
 *      案例7: 图的m着色问题
 *      n个结点,m中颜色.
 *      解向量: (x1,,,xn) xi代表i结点着的颜色.子集树
 *      隐式约束: xi = {1,2,..m}
 *      显示约束: 有相邻边的两个结点不能同色
 *
 *      案例8: 一个有趣的高精度数:
 *      构造一个尽可能大的数，使其从高到低满足前一位能被1整除，前2为能被2整除，…, 前n位能被n整除
 *
 *
 *
 *
 *
 *
 *
 */
public class ReadMe {
}
