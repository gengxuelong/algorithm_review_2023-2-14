package code.b_分治法.readme;

/**
 * @author GengXuelong
 * @version 1.0
 * {@code Mail} 3349495429@qq.com
 * {@code time} 2023/2/26 16:17
 * {@code className} ReadMe
 * {@code description}:
 *      问题的复杂度一般都与问题的规模相关，，问题的规模
 *      分治法基本思想：将一个难以解决的大问题，分解为 问题规模较小的相同子问题。各个击破，分而治之
 *      递归是分治法中最常用的技术
 *      子问题是相互独立的：子问题之间不包含公共子问题
 *      分治法求解过程：划分   求解子问题  合并
 *
 *      基本模式：、
 *      divide-and-conquer(P){
 *          if ( | P | <= n0) adhoc(P); //解决小规模的问题
 *          divide P into smaller subinstances P1,P2,...,Pk；//分解问题
 *          for (i=1; i<=k; i++)
 *          yi=divide-and-conquer(Pi); //递归的解各子问题
 *          return merge(y1,...,yk); //将各子问题的解合并为原问题的解
 *      }
 *
 *      平衡子问题：是的子问题规模大致一样的做法几乎总是比子问题规模不等的做法要好
 *
 *      递归时间复杂度的求解：
 *      套用公式法给出求解如下形式的递归式的方法：
 * 			T(n) = aT(n/b) + f(n)
 * 		这里涉及的三类情况，都是将 f(n)与n^log_ba作比较:
 *      (1)如果n^log_ba > f(n)， 则T(n) = Θ(n^log_ba)
 *      (2)如果n^log_ba = f(n)，则T(n) = Θ(n^log_ba·logn) 或 T(n) = Θ(f(n)·logn)
 *      (3)如果n^log_ba < f(n)，则T(n) = f(n)
 *
 *      案例一：全排列，少有的 T(n) = aT(n-1) + f(n)，a = n,f(n) = O(n)类型，时间复杂度为n*n!
 *
 *      案例二: 整数划分问题，
 *      将正整数n划分成一系列正整数之和，求不同的划分个数。这个题是典型的引入第三变量进而凑递归的类型，本身递归不明显
 *      这个单纯的对n划分显然没啥用，设m为划分组合中不大于m的情况，可知道一下情况：
 *      当m>n： result(m,n)  = result(n,n)
 *      m<=n: 当m = 1 or n = 1 : result = 1
 *           else: result(m,n) = result(m-1,n) + result( m,n-m)
 *      由此可以得到递归方程。
 *
 *      案例三： 二进制大数乘法
 *      乘法往往是计入时间复杂度的量，而忽略加法的存在，乘法决定数量级，加法决定后面跟的较小量，所以不用在乎加法的存在
 *
 *      案例四： 矩阵乘法，常规的矩阵乘法一般时间复杂度为： n * n^2,n代表单个数得出需要乘n下（不考虑相加），而一共需要n^2个数
 *      利用递归的思想，将二阶矩阵作为基础矩阵，将大矩阵化为二阶矩阵，每个值为一个n/2阶的小矩阵，
 *      此时我们需要算的乘法数目为 n^3 = 2^3 = 8；所以递推方程中，a = 8,b =2 ,log_28 = 3,合并需要的时间复杂度为n^2个相加，
 *      也就是f(n) = n^3,显然 n^3 > n^2，所以，时间复杂度还是为n^3，利用常规的递归并没有提升时间复杂度的优化程度
 *      矩阵乘法: strassen改进方案,将乘法变成了7个!加法真涨到了18个,虽然变成了18个,但根据逻辑判断可以知道,合并的时间复杂度还是O(n^2)
 *      基于2阶矩阵的话,已经证明至少需要7次乘法,但是可以从3阶 5阶等矩阵进行研究.但是可以优化时间复杂度的
 *
 *      案例五: 合并排序,合并排序需要辅助的空间O(n),2*T(n/2) + O(n) ,整体时间复杂度为n*log2_n;辅助空间复杂度为O(n)
 *
 *      案例六: 快速排序
 *
 *
 *
 *
 */
public class ReadMe {
}
